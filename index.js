const express = require('express');
const { exec, spawn } = require('child_process');
const axios = require('axios');
const youtubedl = require('youtube-dl-exec'); // Biblioteca principal para download/extrair informa√ß√µes
const { JSDOM } = require('jsdom');
const fs = require('fs');
const path = require('path');

// Pasta tempor√°ria para armazenar arquivos de convers√£o
const tmpFolder = './tmp';

// Cria a pasta tempor√°ria se n√£o existir
if (!fs.existsSync(tmpFolder)) {
    fs.mkdirSync(tmpFolder);
    console.log('üìÅ Pasta tempor√°ria criada:', tmpFolder);
}

// Configura√ß√µes do Express
const app = express();
const port = 3000;

/**
 * Rota para TikTok
 */
app.get('/api/tiktok', async (req, res) => {
    const { url } = req.query;

    if (!url) {
        console.error('‚ùå TikTok: URL n√£o fornecida.');
        return res.status(400).json({ error: 'O par√¢metro "url" √© obrigat√≥rio.' });
    }

    try {
        console.log('üîÑ TikTok: Processando URL:', url);
        const apiUrl = `https://www.tikwm.com/api/?url=${url}`;
        const response = await axios.get(apiUrl);

        if (response.data && response.data.data) {
            console.log('‚úîÔ∏è TikTok: Dados obtidos:', response.data.data);
            return res.json(response.data.data);
        } else {
            console.error('‚ùå TikTok: Erro ao obter dados do v√≠deo.');
            return res.status(500).json({ error: 'Erro ao obter dados do v√≠deo.' });
        }
    } catch (error) {
        console.error('‚ùå TikTok: Erro:', error.message);
        return res.status(500).json({ error: 'Erro ao processar o link do TikTok.' });
    }
});

/**
 * Rota para YouTube (usando youtube-dl-exec)
 * Aceita cookies.txt para casos de restri√ß√£o/idade.
 */
app.get('/api/youtube', async (req, res) => {
    const { url } = req.query;

    if (!url) {
        console.error('‚ùå YouTube: URL n√£o fornecida.');
        return res.status(400).json({ error: 'O par√¢metro "url" √© obrigat√≥rio.' });
    }

    try {
        console.log('üîÑ YouTube: Processando URL:', url);

        // Verifica se existe o arquivo cookies.txt
        const cookiesPath = path.resolve('./cookies.txt');
        if (!fs.existsSync(cookiesPath)) {
            console.warn('‚ö†Ô∏è YouTube: Arquivo cookies.txt n√£o encontrado. Continuando sem cookies...');
        }

        // Obter informa√ß√µes do v√≠deo
        const videoInfo = await youtubedl(url, {
            dumpSingleJson: true,
            format: 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]',
            cookies: fs.existsSync(cookiesPath) ? './cookies.txt' : undefined,
            addHeader: [
                'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
                'Accept-Language: en-US,en;q=0.9',
                'Referer: https://www.youtube.com/',
            ],
        });

        console.log('‚úîÔ∏è YouTube: Dados obtidos:', videoInfo);

        // Filtra o melhor formato MP4
        const videoFormat = videoInfo.formats.find(
            (format) =>
                format.ext === 'mp4' &&
                format.acodec !== 'none' &&
                format.vcodec !== 'none' &&
                !format.url.includes('.m3u8')
        );
        // Tenta encontrar MP3 ou √°udio puro
        const audioFormat = videoInfo.formats.find(
            (format) =>
                format.ext === 'mp3' ||
                (format.acodec !== 'none' && format.vcodec === 'none' && !format.url.includes('.m3u8'))
        );

        // Tamanho aproximado do v√≠deo (pode ser nulo)
        const videoSize = videoFormat ? (videoFormat.filesize || videoFormat.filesize_approx) : null;

        const formattedData = {
            title: videoInfo.title || 'T√≠tulo n√£o dispon√≠vel',
            duration: videoInfo.duration
                ? `${Math.floor(videoInfo.duration / 60)} min ${videoInfo.duration % 60} sec`
                : 'Dura√ß√£o n√£o dispon√≠vel',
            uploader: videoInfo.uploader || 'Uploader desconhecido',
            views: videoInfo.view_count || 'N/A',
            thumbnail: videoInfo.thumbnail || '',
            mp4_link: videoFormat ? videoFormat.url : 'MP4 n√£o dispon√≠vel',
            mp3_link: audioFormat ? audioFormat.url : 'MP3 n√£o dispon√≠vel',
            filesize: videoSize,
        };

        console.log('‚úîÔ∏è YouTube: Dados formatados:', formattedData);
        return res.json(formattedData);
    } catch (error) {
        console.error('‚ùå YouTube: Erro:', error.message);
        return res.status(500).json({ error: 'Erro ao processar o link do YouTube.' });
    }
});

/**
 * Rota para Instagram (melhor resolu√ß√£o + informa√ß√µes extras)
 */
app.get('/api/instagram', async (req, res) => {
  const { url } = req.query;

  if (!url) {
      return res.status(400).json({ error: 'O par√¢metro "url" √© obrigat√≥rio.' });
  }

  try {
      console.log('üîÑ Instagram: Processando URL:', url);

      // Se tiver cookies do Instagram em 'instagram.txt'
      const cookiesPath = path.resolve('./instagram.txt');
      const hasCookies = fs.existsSync(cookiesPath);

      // Extrai v√≠deo ou imagem usando youtubedl
      const videoInfo = await youtubedl(url, {
          dumpSingleJson: true,
          cookies: hasCookies ? './instagram.txt' : undefined,
          addHeader: [
              'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
              'Accept-Language: en-US,en;q=0.9',
              'Referer: https://www.instagram.com/',
          ],
          // Tenta extrair v√≠deo MP4
          format: 'best[ext=mp4]',
      });

      // Exibe todo o JSON no console (para depura√ß√£o)
      console.log('üîç Instagram: JSON completo videoInfo =', JSON.stringify(videoInfo, null, 2));

      // Coletar informa√ß√µes extras (se existirem)
      const {
          id,
          title,
          description,
          like_count,
          comment_count,
          duration,
          uploader,
          channel,
          timestamp
          // ... etc.
      } = videoInfo;

      // Vamos procurar o melhor formato de v√≠deo (maior resolu√ß√£o)
      const allVideoFormats = (videoInfo.formats || [])
          .filter(fmt => fmt.ext === 'mp4' && fmt.vcodec !== 'none'); 

      let bestFormat = null;
      let bestResolution = 0;
      for (const f of allVideoFormats) {
          const w = f.width || 0;
          const h = f.height || 0;
          const area = w * h;
          if (area > bestResolution) {
              bestResolution = area;
              bestFormat = f;
          }
      }

      // Se encontrou algum formato de v√≠deo
      if (bestFormat) {
          // Tentar achar √°udio (m4a) opcional
          const audioFormat = videoInfo.formats?.find(f => f.ext === 'm4a');

          // Exemplo de retorno com v√°rias infos extras
          return res.json({
              id: id || null,
              title: title || 'Sem T√≠tulo',
              description: description || 'Sem descri√ß√£o',
              like_count: like_count ?? 0,
              comment_count: comment_count ?? 0,
              uploader: uploader || 'Desconhecido',
              channel: channel || '',  // ou "Sem canal"
              duration: duration ?? null,
              timestamp: timestamp ?? null,
              mp4_link: bestFormat.url,
              mp3_link: audioFormat?.url || null,
              resolution: bestFormat.width && bestFormat.height
                  ? `${bestFormat.width}x${bestFormat.height}`
                  : 'Desconhecida',
          });
      } else {
          // Caso n√£o tenha v√≠deo, tentamos extrair imagens
          const imageItems = [];

          // 1) Tenta requested_downloads (√†s vezes tem .jpg)
          if (videoInfo.requested_downloads) {
              for (const item of videoInfo.requested_downloads) {
                  if (item.ext === 'jpg' || item.ext === 'jpeg') {
                      imageItems.push(item.url);
                  }
              }
          }

          // 2) Se n√£o achou nada, faz scraping manual
          if (!imageItems.length) {
              const resp = await axios.get(url, {
                  headers: {
                      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
                  },
              });
              const dom = new JSDOM(resp.data);
              const document = dom.window.document;
              const foundImages = Array.from(document.querySelectorAll('img[src]')).map((img) => img.src);
              imageItems.push(...foundImages);
          }

          if (imageItems.length) {
              // Inclu√≠mos tamb√©m as infos extras (como description, etc.) se quiser
              return res.json({
                  type: 'images',
                  images: imageItems,
                  title: title || 'Post de Imagens',
                  description: description || 'Sem descri√ß√£o',
                  like_count: like_count ?? 0,
                  comment_count: comment_count ?? 0,
                  uploader: uploader || 'Desconhecido',
                  channel: channel || '',
                  duration: duration ?? null
              });
          }

          // Se nada encontrado
          return res.status(404).json({
              error: 'N√£o foi poss√≠vel extrair v√≠deo ou imagem do Instagram.'
          });
      }
  } catch (error) {
      console.error('‚ùå Instagram: Erro:', error.message);
      return res.status(500).json({ error: 'Erro ao processar o link do Instagram.' });
  }
});


/**
 * Rota para Kwai
 */
app.get('/api/kwai', async (req, res) => {
    const { url } = req.query;

    if (!url) {
        console.error('‚ùå Kwai: URL n√£o fornecida.');
        return res.status(400).json({ error: 'O par√¢metro "url" √© obrigat√≥rio.' });
    }

    try {
        console.log('üîÑ Kwai: Processando URL:', url);

        const videoInfo = await youtubedl(url, {
            dumpSingleJson: true,
            format: 'best[ext=mp4]',
        });

        console.log('‚úîÔ∏è Kwai: Dados obtidos:', videoInfo);

        const title = videoInfo.title || '';
        const uploaderName = title.split('(')[0].trim();
        const uploaderHandle = title.match(/\((.*?)\)/)?.[1] || 'Desconhecido';

        const formattedData = {
            id: videoInfo.id || 'ID n√£o dispon√≠vel',
            title: videoInfo.title || 'T√≠tulo n√£o dispon√≠vel',
            description: videoInfo.description || 'Descri√ß√£o n√£o dispon√≠vel',
            duration: videoInfo.duration
                ? `${Math.floor(videoInfo.duration / 60)} min ${videoInfo.duration % 60} sec`
                : 'Dura√ß√£o n√£o dispon√≠vel',
            uploader: uploaderName || 'Uploader desconhecido',
            uploader_handle: `@${uploaderHandle}`,
            view_count: videoInfo.view_count || 0,
            like_count: videoInfo.like_count || 0,
            thumbnail: videoInfo.thumbnail || '',
            video_url: videoInfo.url || 'MP4 n√£o dispon√≠vel',
            webpage_url: videoInfo.webpage_url || url,
        };

        console.log('‚úîÔ∏è Kwai: Dados formatados:', formattedData);
        return res.json(formattedData);
    } catch (error) {
        console.error('‚ùå Kwai: Erro:', error.message);
        return res.status(500).json({ error: 'Erro ao processar o link do Kwai.' });
    }
});

/**
 * Rota para Facebook
 */
app.get('/api/facebook', async (req, res) => {
    const { url } = req.query;

    if (!url) {
        console.error('‚ùå Facebook: URL n√£o fornecida.');
        return res.status(400).json({ error: 'O par√¢metro "url" √© obrigat√≥rio.' });
    }

    try {
        console.log('üîÑ Facebook: Processando URL:', url);

        const videoInfo = await youtubedl(url, {
            dumpSingleJson: true,
            format: 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]',
        });

        console.log('‚úîÔ∏è Facebook: Dados obtidos:', videoInfo);

        const videoFormat = videoInfo.formats.find(
            (format) =>
                format.ext === 'mp4' &&
                format.acodec !== 'none' &&
                format.vcodec !== 'none' &&
                !format.url.includes('.m3u8')
        );
        const audioFormat = videoInfo.formats.find(
            (format) =>
                format.ext === 'm4a' ||
                (format.acodec !== 'none' && format.vcodec === 'none' && !format.url.includes('.m3u8'))
        );

        const formattedData = {
            id: videoInfo.id || 'ID n√£o dispon√≠vel',
            title: videoInfo.title || 'T√≠tulo n√£o dispon√≠vel',
            description: videoInfo.description || 'Descri√ß√£o n√£o dispon√≠vel',
            duration: videoInfo.duration
                ? `${Math.floor(videoInfo.duration / 60)} min ${Math.round(videoInfo.duration % 60)} sec`
                : 'Dura√ß√£o n√£o dispon√≠vel',
            uploader: videoInfo.uploader || 'Uploader desconhecido',
            thumbnail: videoInfo.thumbnail || '',
            mp4_link: videoFormat ? videoFormat.url : 'MP4 n√£o dispon√≠vel',
            mp3_link: audioFormat ? audioFormat.url : 'MP3 n√£o dispon√≠vel',
            view_count: videoInfo.view_count || 'N/A',
        };

        console.log('‚úîÔ∏è Facebook: Dados formatados:', formattedData);
        return res.json(formattedData);
    } catch (error) {
        console.error('‚ùå Facebook: Erro:', error.message);
        return res.status(500).json({ error: 'Erro ao processar o link do Facebook.' });
    }
});

/**
 * Rota para Pinterest
 */
app.get('/api/pinterest', async (req, res) => {
    const { url } = req.query;

    if (!url) {
        console.error('‚ùå Pinterest: URL n√£o fornecida.');
        return res.status(400).json({ error: 'O par√¢metro "url" √© obrigat√≥rio.' });
    }

    try {
        console.log('üîÑ Pinterest: Processando URL:', url);

        // Primeiro, tenta extrair v√≠deo via youtubedl
        let videoInfo;
        try {
            videoInfo = await youtubedl(url, {
                dumpSingleJson: true,
                format: 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]',
            });

            console.log('‚úîÔ∏è Pinterest: Dados de v√≠deo obtidos (yt-dlp):', videoInfo);

            const videoFormat = videoInfo.formats.find(
                (format) =>
                    format.ext === 'mp4' &&
                    format.acodec !== 'none' &&
                    format.vcodec !== 'none' &&
                    !format.url.includes('.m3u8')
            );

            // Se encontrou v√≠deo, retorna
            const formattedVideoData = {
                title: videoInfo.title || 'T√≠tulo n√£o dispon√≠vel',
                description: videoInfo.description || 'Descri√ß√£o n√£o dispon√≠vel',
                duration: videoInfo.duration
                    ? `${Math.floor(videoInfo.duration / 60)} min ${videoInfo.duration % 60} sec`
                    : 'Dura√ß√£o n√£o dispon√≠vel',
                uploader: videoInfo.uploader || 'Uploader desconhecido',
                thumbnail: videoInfo.thumbnail || '',
                mp4_link: videoFormat ? videoFormat.url : 'MP4 n√£o dispon√≠vel',
            };

            return res.json(formattedVideoData);
        } catch (error) {
            console.warn('‚ùå Pinterest: Falha ao obter v√≠deo. Tentando buscar imagens...', error.message);
        }

        // Caso n√£o seja v√≠deo, faz scraping de imagens
        const response = await axios.get(url, {
            headers: {
                'User-Agent':
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',
            },
        });

        const dom = new JSDOM(response.data);
        const document = dom.window.document;
        let imageUrls = Array.from(document.querySelectorAll('img[src]')).map((img) => img.src);

        if (!imageUrls.length) {
            console.error('‚ùå Pinterest: Nenhuma imagem encontrada.');
            return res.status(500).json({ error: 'Nenhuma m√≠dia encontrada.' });
        }

        // Filtra imagens pequenas
        const minSize = 200;
        imageUrls = imageUrls.filter((imgUrl) => {
            const match = imgUrl.match(/\/(\d{2,4})x(\d{2,4})\//);
            if (match) {
                const width = parseInt(match[1], 10);
                const height = parseInt(match[2], 10);
                return width >= minSize && height >= minSize;
            }
            return true;
        });

        if (!imageUrls.length) {
            console.warn('‚ö†Ô∏è Pinterest: Todas as imagens filtradas eram muito pequenas.');
            imageUrls = Array.from(document.querySelectorAll('img[src]')).map((img) => img.src);
        }

        // Ordena por resolu√ß√£o (maior para menor)
        imageUrls.sort((a, b) => {
            const getRes = (url) => {
                const match = url.match(/\/(\d{2,4})x(\d{2,4})\//);
                if (match) {
                    return parseInt(match[1], 10) * parseInt(match[2], 10);
                }
                return 0;
            };
            return getRes(b) - getRes(a);
        });

        const formattedImageData = {
            title: 'Imagem do Pinterest',
            description: 'Imagem obtida do Pinterest',
            thumbnail: imageUrls[0],
            image_links: imageUrls,
        };

        console.log('‚úîÔ∏è Pinterest: Dados de imagem formatados:', formattedImageData);
        return res.json(formattedImageData);
    } catch (error) {
        console.error('‚ùå Pinterest: Erro ao processar o link.', error.message);
        return res.status(500).json({ error: 'Erro ao processar o link do Pinterest.' });
    }
});

/**
 * Rota gen√©rica para outras plataformas (Twitter, etc.)
 */
app.get('/api/others', async (req, res) => {
    const { url } = req.query;

    if (!url) {
        console.error('‚ùå Gen√©rica: URL n√£o fornecida.');
        return res.status(400).json({ error: 'O par√¢metro "url" √© obrigat√≥rio.' });
    }

    try {
        console.log('üîÑ Gen√©rica: Processando URL:', url);
        const videoInfo = await youtubedl(url, {
            dumpSingleJson: true,
            format: 'best[ext=mp4]',
        });

        console.log('‚úîÔ∏è Gen√©rica: Dados obtidos:', videoInfo);
        return res.json(videoInfo);
    } catch (error) {
        console.error('‚ùå Gen√©rica: Erro:', error.message);
        return res.status(500).json({ error: 'Erro ao processar o link.' });
    }
});

/**
 * Fun√ß√£o para limpar arquivos antigos (mais de 10 minutos)
 */
const cleanupTempFiles = () => {
    fs.readdir(tmpFolder, (err, folders) => {
        if (err) return console.error('‚ùå Erro ao listar diret√≥rios tempor√°rios:', err);

        const now = Date.now();

        folders.forEach((folder) => {
            const folderPath = path.join(tmpFolder, folder);

            fs.readdir(folderPath, (err, files) => {
                if (err) {
                    // Se n√£o for pasta
                    if (err.code === 'ENOTDIR') {
                        fs.unlink(folderPath, (unlinkErr) => {
                            if (!unlinkErr) console.log('üóëÔ∏è Arquivo √≥rf√£o removido:', folderPath);
                        });
                        return;
                    }
                    return console.error('‚ùå Erro ao listar arquivos da pasta:', err);
                }

                files.forEach((file) => {
                    const filePath = path.join(folderPath, file);
                    fs.stat(filePath, (err, stats) => {
                        if (err) return console.error('‚ùå Erro ao obter informa√ß√µes do arquivo:', err);

                        // Se o arquivo for mais antigo que 10 minutos
                        if (now - stats.mtimeMs > 10 * 60 * 1000) {
                            fs.unlink(filePath, (err) => {
                                if (err) return console.error('‚ùå Erro ao remover arquivo tempor√°rio:', err);
                                console.log('üóëÔ∏è Arquivo tempor√°rio removido:', filePath);
                            });
                        }
                    });
                });
            });
        });
    });
};
// Executa a limpeza a cada 10 minutos
setInterval(cleanupTempFiles, 10 * 60 * 1000);

/**
 * Rota para convers√£o (bitrate reduzido, usando youtube-dl-exec + cookies)
 */
app.get('/api/convert/:userId', async (req, res) => {
    const { userId } = req.params;
    const { url, format = 'mp3' } = req.query;

    if (!url) {
        console.error('‚ùå Convers√£o: URL n√£o fornecida.');
        return res.status(400).json({ error: 'O par√¢metro "url" √© obrigat√≥rio.' });
    }

    try {
        console.log(`üîÑ Convers√£o: Processando URL para ${format}:`, url);

        const cookiesPath = path.resolve('./cookies.txt');
        if (!fs.existsSync(cookiesPath)) {
            console.warn('‚ö†Ô∏è Convers√£o: Arquivo cookies.txt n√£o encontrado. Continuando sem cookies...');
        }

        // Obter URL de √°udio
        const videoInfo = await youtubedl(url, {
            dumpSingleJson: true,
            format: 'bestaudio/best',
            cookies: fs.existsSync(cookiesPath) ? './cookies.txt' : undefined,
            addHeader: [
                'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
                'Accept-Language: en-US,en;q=0.9',
            ],
        });

        const audioUrl = videoInfo.url;
        if (!audioUrl) {
            console.error('‚ùå Convers√£o: N√£o foi poss√≠vel obter a URL do √°udio.');
            return res.status(500).json({ error: 'N√£o foi poss√≠vel obter a URL do √°udio.' });
        }
        console.log('‚úîÔ∏è URL de √°udio direto obtida:', audioUrl);

        // Cria pasta do usu√°rio, se n√£o existir
        const userFolder = path.join(tmpFolder, userId);
        if (!fs.existsSync(userFolder)) fs.mkdirSync(userFolder);

        // Caminho de sa√≠da do arquivo convertido
        const tempFilePath = path.join(userFolder, `converted.${format}`);

        console.log('üîÑ Executando convers√£o com ffmpeg (64kbps)...');
        const command = [
            'ffmpeg',
            '-y', // sobrescreve se j√° existir
            '-i', audioUrl,
            '-codec:a', format === 'mp3' ? 'libmp3lame' : 'aac',
            '-b:a', '64k',
            '-ac', '2',
            '-ar', '44100',
            tempFilePath,
        ];

        const process = spawn(command[0], command.slice(1));

        process.stderr.on('data', (data) => {
            console.error(`‚ö†Ô∏è ffmpeg STDERR: ${data}`);
        });

        process.on('close', (code) => {
            if (code === 0) {
                console.log('‚úîÔ∏è Convers√£o conclu√≠da com sucesso:', tempFilePath);
                const fileUrl = `${req.protocol}://${req.get('host')}/${userId}/converted.${format}`;
                return res.json({ audioUrl: fileUrl });
            } else {
                console.error('‚ùå Convers√£o: Processo de convers√£o falhou com c√≥digo:', code);
                return res.status(500).json({ error: 'Falha no processo de convers√£o com ffmpeg.' });
            }
        });
    } catch (error) {
        console.error('‚ùå Convers√£o: Erro inesperado.', error.message);
        return res.status(500).json({ error: 'Erro inesperado durante a convers√£o.' });
    }
});

// Rota para servir arquivos tempor√°rios ap√≥s a convers√£o
app.use('/:userId', express.static(tmpFolder));

// Inicia o servidor
app.listen(port, () => {
    console.log(`Servidor rodando em http://localhost:${port}`);
});
